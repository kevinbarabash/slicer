<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <title>Slicer</title>
  <script src="../lib/three.min.js"></script>
  <script src="../lib/OrbitControls.js"></script>
  <style>
    body {
      margin: 0;
    }
  </style>
</head>
<body>

</body>
</html>
<script>
  var scene = new THREE.Scene();
  var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

  var renderer = new THREE.WebGLRenderer();
  renderer.setClearColor(0x333333);
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // TODO: switch to orthographic camera
  // TODO: expose more uniforms, e.g. opacity
  // TODO: add sliders to uniforms
  // TODO: add axes and a grid on the xy plane
  // TODO: equilateral triangle grid
  // TODO: automatic subdivision to model details

  function gauss(x,y) {
    return Math.pow(Math.E, -(x*x + y*y));
  }

  function waves(x,y) {
    return (Math.cos(5 * x * y)) / 5;
  }

  var grid = [];
  var count = 256;

  var xMin = -2;
  var xMax = 2;
  var yMin = 0;
  var yMax = 2;
  var xStep = (xMax - xMin) / count;
  var yStep = (yMax - yMin) / count;

  var x = xMin;
  for (var i = 0; i < count + 1; i++, x += xStep) {
    grid[i] = [];
    var y = yMin;
    for (var j = 0; j < count + 1; j++, y += yStep) {
      var z = gauss(x,y);
      grid[i][j] = new THREE.Vector3(x, y, z);
    }
  }

  var geometry = new THREE.Geometry();

  var index = 0;
  for (var i = 0; i < count; i++) {
    for (var j = 0; j < count; j++) {
      var p1 = grid[i][j];
      var p2 = grid[i+1][j];
      var p3 = grid[i+1][j+1];
      var p4 = grid[i][j+1];

      geometry.vertices.push(p1);
      geometry.vertices.push(p2);
      geometry.vertices.push(p3);
      geometry.vertices.push(p4);

      // puts the diagonal bias in the other direction
//      geometry.faces.push(new THREE.Face3(index + 0, index + 1, index + 2));
//      geometry.faces.push(new THREE.Face3(index + 2, index + 3, index + 0));

      geometry.faces.push(new THREE.Face3(index + 0, index + 1, index + 3));
      geometry.faces.push(new THREE.Face3(index + 1, index + 2, index + 3));

      index += 4;
    }
  }

  geometry.mergeVertices();
  geometry.computeFaceNormals();
  geometry.computeVertexNormals();


  var vertexShader =
      "varying vec3 vNormal;\n" +
      "\n" +
      "void main(void) {\n" +
      "  vNormal = normalize(normalMatrix * normal);\n" +
      "  gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\n" +
      "}";

  var fragmentShader =
      "precision mediump float;\n" +
      "varying vec3 vNormal;\n" +
      "uniform vec3 uColor;\n" +
      "\n" +
      "void main(void) {\n" +
      "  vec3 light = vec3(0.0, 0.0, 1.0);\n" +
      "  float alpha = 0.2 + 0.7 * ( 1.0 - abs(dot(vNormal, light)) );\n" +
      "  gl_FragColor = vec4(uColor, alpha);\n" +
      "}";

  var attributes = {};
  var uniforms = {
    uColor: {
      type: 'v3',
      value: new THREE.Vector3(1.0, 1.0, 0.0)
    }
  };

  var material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    attributes: attributes,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    transparent: true,
    side: THREE.DoubleSide,
    depthTest: false,
    depthWrite: false
  });

  var cube = new THREE.Mesh(geometry, material);
  scene.add(cube);

  camera.position.z = 3;

  var directionalLight = new THREE.DirectionalLight(0xc0c0c0);
  directionalLight.position.set(1, 1, 1).normalize();
  scene.add(directionalLight);

  var ambient = new THREE.AmbientLight( 0x101010 );
  scene.add( ambient );

  var render = function () {
    requestAnimationFrame(render, renderer.domElement);
    renderer.render(scene, camera);
  };

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  render();
</script>
